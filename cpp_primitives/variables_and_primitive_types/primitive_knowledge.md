# Primitive knowledge

## Primitive Types

C++定义了算术类型和空类型两种内置基本数据类型，其中算术类型包含`char`、`int`、`bool`和`float`。`NULL`不对应具体的值，仅用于特殊场合。

除去`bool`和扩展类型，其他整型可以划分为`signed`和`unsigned`两种。`signed`只能表示大于0的值。然而，字符型同其他整型不同，虽然字符型被划分了三种：`char`、`signed char`、`unsigned char`，其中`char`和`signed char`并不相同，但字符的表现形式依旧只有两种。`char`的表现形式却决于编译器。

如果我们赋给`unsigned`一个超出它表示范围的值时，结果是初始值对`unsigned`表示数值总数取模后的余数。

```cpp
unsigned int a = 10;
a = -10; // a = (4294967296 - 10) % 4294967296
cout << a << endl; // 4294967286
```

如果我们赋给`signed`超出它表示范围的值时，结果是`undefined`的。

注：如果一个算术表达式中既有`unsiged`和`signed`时，`signed`会转化为`unsigned`，开发者应该避免这样的行为。

## Variables

变量提供一个具有名字，可供程序操作的存储空间。每个变量都有其数据类型，数据类型决定变量所占内存空间的大小和布局方式。

变量**定义**规定了变量的类型、名字和申请存储空间，还可能为变量赋予初始值，而变量**声明**只规定了变量的类型和名字。

```cpp
int a = 0, b, c; // 定义了变量a，b，c，给a赋予了初始值 0
```

C++允许将程序拆分为多个逻辑部件来编写，C++支持分离式编译机制。为了支持**分离式编译**，C++语言将声明和定义区分开来。声明使得名字为程序所知，一个文件想用别处定义的名字必须包含对那个名字的声明。而定义负责创建于名字关联的实体。

```cpp
extern int i; // 声明
int j; // 定义
extern int m = 0; // 定义
```

## 常量

我个人认为常量分为字面值常量、`const`常量以及宏常量。所谓常量，就是可被修改的数据或者对象。

```cpp
#define int MAX = 65535; // 宏常量
5;
"ahfhdas"; // 字面值常量
const int a = 10; // const 常量
```

在执行拷贝时，顶层`const`不受任何影响。然而底层`const`拷入和拷出时必须具备相同的底层`const`必须具备相同的底层`const`或者两个数据类型可以相互转换，一般来说，非常常量可以转化为常量。

## `Reference` & `Pointer`

**不同点**

**引用**是对象的别名，（非`const`）定义时必须初始化，而且制定绑定到对象上，不可与字面值或者某个表达式的计算结果绑定。

**指针**本身就是一个对象，允许对指针赋值和拷贝，在生命周期内可以先后指向多个不同的对象。指针在定义时和其他内置类型一样。

**相同点**

（非`const`）所有引用的类型和与之绑定的对象严格匹配；所有指针的类型必须和指向对象的类型严格匹配。

当引用和指针是`const`类型时，允许绑定和指向的对象指是常量和非常量。

## `auto` & `decltype`

**`auto`**依据表达式的初始值推断类型，尽管一条语句可以声明多个变量，但所有变量的初始基本数据类型**必须一致**。

当引用被当作初始值，真正参与的是引用对象的值，所以得到的类型也是引用对象的值的类型；auto一般会忽略顶层

`const`，同时底层`const`会被保留;设置一个`auto &`时，顶层常量属性会被保留。

**`decltype`**分析表达式得到数据的类型。

如果表达式是一个变量，`decltype`返回这变量的类型（包含顶层`const`和引用）。

注：`decltype((variable))`得到的是一个引用

## **`String`**

字符串相加时，必须保证`+`左右至少要有一个`String`（从左至右）；允许`String`对象的复合赋值运算中允许使用**空字符**结束的字符数组作为右侧的运算对象

`C`风格的字符串都以**空字符**结尾

```cpp
string s("Hello World");
char * cs = s; // 不可以使用string对象初始化char*
const char *str = s.c_str(); // string 专门提供了c_str的成员函数，返回的就是cosnt char *str;
```

## 内置数组

不可以将数组的内容拷贝给其他数组作为初始值，也不可以为其他数组赋值；使用数组的时候编译器会自动转换为一个指向数组首元素的指针；

```cpp
int a[] = {1, 3, 4};
int b[] = a; // 不允许用一个数组初始化另一个数组
int b[3] = {1, 3, 4};
b = a; // 不允许把一个数组直接赋给另一个数组
```

**复杂数组的声明**

```cpp
int arr[10] = {0};
int (*parr)[10] = &arr; // parr是一个指针，指向一个含有十个数的数组
int (&rarr)[10] = arr; // rarr 是一个引用， 绑定的对象是一个数组
```

## 左值和右值

左值是指表达式结束后依然存在的持久化对象；右值是指表达式结束后就**“消失”**的临时对象，没有名称，通常只是临时计算的结果

## 类型转换

类型转换就是从一种给定类型转换为另一种类型；只有类型之间存在关联，两种类型就可以相互转换。

**隐式转换：**类型就行转换时是自动执行的，不需要程序员的介入

**显示类型转换：**显示将对象强制转换成另外一种类型

+ `type (expr)`  或者 `type (expr)`

+ `static_cast<type>(expression)`
  + 能隐式转换；数值类型；父子类型；指针类型；其他合法类型
+ `const_cast<type>(expression)`：将常量对象或指针转换为非常量对象或指针
  + 去除表达式中的`const`限定符
  + 转换后的对象或者指针可以用于修改原本`const`限定的值，但可能会产生未定义的行为
+ ``reinterpret_cast<type>(expression)`
  + 用于进行底层的、不安全的类型转换
  + 将一个**指针或引用**转换为不同类型的指针或引用
  + 将**指针或引用**转换为**整数类型**，或者将整数类型转换为指针或引用

