# Primitive knowledge

## Primitive Types

C++定义了算术类型和空类型两种内置基本数据类型，其中算术类型包含`char`、`int`、`bool`和`float`。`NULL`不对应具体的值，仅用于特殊场合。

除去`bool`和扩展类型，其他整型可以划分为`signed`和`unsigned`两种。`signed`只能表示大于0的值。然而，字符型同其他整型不同，虽然字符型被划分了三种：`char`、`signed char`、`unsigned char`，其中`char`和`signed char`并不相同，但字符的表现形式依旧只有两种。`char`的表现形式却决于编译器。

如果我们赋给`unsigned`一个超出它表示范围的值时，结果是初始值对`unsigned`表示数值总数取模后的余数。

```cpp
unsigned int a = 10;
a = -10; // a = (4294967296 - 10) % 4294967296
cout << a << endl; // 4294967286
```

如果我们赋给`signed`超出它表示范围的值时，结果是`undefined`的。

注：如果一个算术表达式中既有`unsiged`和`signed`时，`signed`会转化为`unsigned`，开发者应该避免这样的行为。

## Variables

变量提供一个具有名字，可供程序操作的存储空间。每个变量都有其数据类型，数据类型决定变量所占内存空间的大小和布局方式。

变量**定义**规定了变量的类型、名字和申请存储空间，还可能为变量赋予初始值，而变量**声明**只规定了变量的类型和名字。

```cpp
int a = 0, b, c; // 定义了变量a，b，c，给a赋予了初始值 0
```

C++允许将程序拆分为多个逻辑部件来编写，C++支持分离式编译机制。为了支持**分离式编译**，C++语言将声明和定义区分开来。声明使得名字为程序所知，一个文件想用别处定义的名字必须包含对那个名字的声明。而定义负责创建于名字关联的实体。

```cpp
extern int i; // 声明
int j; // 定义
extern int m = 0; // 定义
```

## 常量

我个人认为常量分为字面值常量、`const`常量以及宏常量。所谓常量，就是可被修改的数据或者对象。

```cpp
#define int MAX = 65535; // 宏常量
5;
"ahfhdas"; // 字面值常量
const int a = 10; // const 常量
```

在执行拷贝时，顶层`const`不受任何影响。然而底层`const`拷入和拷出时必须具备相同的底层`const`必须具备相同的底层`const`或者两个数据类型可以相互转换，一般来说，非常常量可以转化为常量。

## `Reference` & `Pointer`

**不同点**

**引用**是对象的别名，（非`const`）定义时必须初始化，而且制定绑定到对象上，不可与字面值或者某个表达式的计算结果绑定。

**指针**本身就是一个对象，允许对指针赋值和拷贝，在生命周期内可以先后指向多个不同的对象。指针在定义时和其他内置类型一样。

**相同点**

（非`const`）所有引用的类型和与之绑定的对象严格匹配；所有指针的类型必须和指向对象的类型严格匹配。

当引用和指针是`const`类型时，允许绑定和指向的对象指是常量和非常量。

## `auto` & `decltype`

**`auto`**依据表达式的初始值推断类型，尽管一条语句可以声明多个变量，但所有变量的初始基本数据类型**必须一致**。

当引用被当作初始值，真正参与的是引用对象的值，所以得到的类型也是引用对象的值的类型；auto一般会忽略顶层

`const`，同时底层`const`会被保留;设置一个`auto &`时，顶层常量属性会被保留。

**`decltype`**分析表达式得到数据的类型。

如果表达式是一个变量，`decltype`返回这变量的类型（包含顶层`const`和引用）。

注：`decltype((variable))`得到的是一个引用

## **`String`**

字符串相加时，必须保证`+`左右至少要有一个`String`（从左至右）；允许`String`对象的复合赋值运算中允许使用**空字符**结束的字符数组作为右侧的运算对象

`C`风格的字符串都以**空字符**结尾

```cpp
string s("Hello World");
char * cs = s; // 不可以使用string对象初始化char*
const char *str = s.c_str(); // string 专门提供了c_str的成员函数，返回的就是cosnt char *str;
```

## 内置数组

不可以将数组的内容拷贝给其他数组作为初始值，也不可以为其他数组赋值；使用数组的时候编译器会自动转换为一个指向数组首元素的指针；

```cpp
int a[] = {1, 3, 4};
int b[] = a; // 不允许用一个数组初始化另一个数组
int b[3] = {1, 3, 4};
b = a; // 不允许把一个数组直接赋给另一个数组
```

**复杂数组的声明**

```cpp
int arr[10] = {0};
int (*parr)[10] = &arr; // parr是一个指针，指向一个含有十个数的数组
int (&rarr)[10] = arr; // rarr 是一个引用， 绑定的对象是一个数组
```

## 左值和右值

左值是指表达式结束后依然存在的持久化对象；右值是指表达式结束后就**“消失”**的临时对象，没有名称，通常只是临时计算的结果

## 类型转换

类型转换就是从一种给定类型转换为另一种类型；只有类型之间存在关联，两种类型就可以相互转换。

**隐式转换：**类型就行转换时是自动执行的，不需要程序员的介入

**显示类型转换：**显示将对象强制转换成另外一种类型

+ `type (expr)`  或者 `type (expr)`

+ `static_cast<type>(expression)`
  + 能隐式转换；数值类型；父子类型；指针类型；其他合法类型
+ `const_cast<type>(expression)`：将常量对象或指针转换为非常量对象或指针
  + 去除表达式中的`const`限定符
  + 转换后的对象或者指针可以用于修改原本`const`限定的值，但可能会产生未定义的行为
+ ``reinterpret_cast<type>(expression)`
  + 用于进行底层的、不安全的类型转换
  + 将一个**指针或引用**转换为不同类型的指针或引用
  + 将**指针或引用**转换为**整数类型**，或者将整数类型转换为指针或引用
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

## 条件语句

**`switch`**

+ `case`关键字和对应值一起被称为`case`标签，`case`标签必须是整数
+ 如果某个`case`标签匹配成功，将从这个标签开始顺序执行所有`case`分支

`goto`

+ 可以用于无条件地将控制转移到程序的标签处

```cpp
#include <iostream>

int main() {
    int i = 0;

label:  // 定义一个标签
    std::cout << i << std::endl;
    i++;

    if (i < 5) {
        goto label;  // 跳转到标签处
    }

    return 0;
}
```

## 函数

### 函数匹配

函数调用选择重载函数时会经历确定**候选函数**和**可行函数**两个步骤

+ 候选函数：同名且已被声明
+ 可行函数：形参数量同，每个实参对应形参类型同且可转化

**大致过程**

+ 编译器找到一个与实参最佳匹配的函数，然后产生调用
+ 找不到任何一个函数与调用的实参匹配，此时编译器发生无匹配错误
+ 有多余一个函数可以匹配，但每一个都不是最佳选择，二义性调用错误

### `inline` & `constexpr`

`inline`：适用于优化规模较小、流程直接、频繁调用的函数

```cpp
inline const string & shorterString(const string &s1, const string &s2){
    return s1.size() <= s2.size() ? s1 : s2;
}
```

`constexpr`：只能用于常量表达式或者常量表达式的函数

+ `constexpr`函数的返回值类型以及所有形参类型都是字面值类型，而且函数体必须有且仅有一条`return`语句

### `assert`&`NDEBUG`

`assert`：

```cpp
#include <cassert>

int divide(int dividend, int divisor) {
    // 断言：除数不能为0
    assert(divisor != 0);

    return dividend / divisor;
}

int main() {
    int result = divide(10, 2);
    // 断言：结果应该为5
    assert(result == 5);

    result = divide(20, 0); // 除数为0，违反了断言条件
    return 0;
}
```

`assert`语句被用来验证程序中的某些假设是否成立。如果断言失败，就说明程序的状态不符合预期，可能存在错误或者逻辑问题，并引发一个异常，终止程序的执。assert语句在发布版本的代码中通常会被禁用，因为它主要用于**调试和开发阶段**.

`NDEBUG`：

是一个预处理宏，用于禁用assert宏的宏定义。当定义了`NDEBUG`宏后，所有包含了assert语句的代码将被编译器忽略。

```cpp
#define NDEBUG
```

### 函数指针

函数指针指向的是函数而非对象。函数指针指向某种特定的类型。**函数的类型**由返回类型和形参类型共同决定，与函数名无关。

```cpp
bool (*pc)(int a, int b); // 未初始化  可以解引用也可以不解
```

当我们使用重载函数时，上下文必须明确的指出我们应该选用那个函数；编译器依据指针类型决定使用哪个函数，指针类型必须与重载函数中的某一个精确匹配。

```cpp
void ff(int a);
void fff(int a, int b);

void (*f)(int a) = ff;
```

**函数指针形参**

```cpp
void useBigger(int a, int b, bool f(int a)); // 自动转换为函数指针

void useBigger(int a, int b, bool (*f)(int a)); // 显示定义函数指针

typedef bool func(int a, int b); // func 是一种函数类型
typedef decltype(fff) func2; // 此时decltype 返回函数类型，而非指针
```

## 类

类的基本思想是数据抽象和封装。数据抽象是一种依赖接口和实现分离的编程技术。类的接口包括用户执行的操作；类的实现包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。

封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，用户只能使用接口而无法访问实现部分。

类要实现数据抽象和封装，需要先定义一个抽象数据类型。在抽象数据类型中，类的设计者负责考虑类的实现过程；使用类的程序员只需要考虑类型做了什么，而无需了解类型的工作细节。

### `class`和`struct`

`class`和`struct`都可以用于定义类，而这唯一的区别是默认访问权限不同；`struct`定义在第一个访问说明符之前的成员是`public`；而`class`则相反。

### `friend`

类允许其他类或者函数访问它的非公有成员

```cpp
class Friend{
    // 为Friend 声明友元
    friend void add();
}
```

友元声明只是限定了访问权限，不是通常意义的函数声明；

### `mutable`

我们希望修改类的某个数据成员，即使是在一个`const`成员内。通过在变量的声明中加入`mutable`关键字实现。 

### 构造函数

+ 在块作用域内不使用任何初始值定义一个非静态变量或者数组
+ 一个类本身含有类类型的成员且使用合成的默认构造函数时
+ 当类类型的成员没有在构造函数初始值中显式初始化

### 聚合类

+ 所有成员都是`public`
+ 没有定义任何构造函数
+ 没有类内初始值
+ 没有基类，也没有`virtual`

### 字面值常量类

数据成员都是字面值类型的聚合类都是字面值常量类。如果一个类不是聚合类，但必须满足以下要求：

+ 数据成员必须是字面值类型
+ 至少有一个`constexpr`构造函数
+ 数据成员含有类内初始值，则内置类型成员的初始值必须是一条长常量表达式；或者成员属于某种类类型，必须使用成员自己的`const`构造函数
+ 类必须使用析构函数的默认定义

```cpp
class Debug{
    public:
    	constexpr Debug(bool b = true): hw(b), io(b), other(b){
            
        }
    private:
    	bool hw;
    	bool io;
    	bool other;
}
```

### **静态成员变量**

在`C++11`中要类内初始化静态成员，则静态成员必须是字面值常量类型

```cpp
class MyClass {
public:
    static const/constexpr int myStaticVar = 10; // 类内直接初始化静态成员变量
};

int main() {
    // 使用静态成员变量
    cout << MyClass::myStaticVar << endl; // 输出：10
    return 0;
}
```

